/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/jupyter-obsidian.ts
var jupyter_obsidian_exports = {};
__export(jupyter_obsidian_exports, {
  default: () => JupyterNotebookPlugin
});
module.exports = __toCommonJS(jupyter_obsidian_exports);
var import_obsidian5 = require("obsidian");

// src/jupyter-env.ts
var import_child_process = require("child_process");
var import_events = require("events");
var import_obsidian = require("obsidian");
var import_path = require("path");
var JupyterEnvironment = class {
  constructor(path, printDebug, pythonExecutable, jupyterTimeoutMs, type, customConfigFolderPath) {
    this.path = path;
    this.printDebug = printDebug;
    this.pythonExecutable = pythonExecutable;
    this.jupyterTimeoutMs = jupyterTimeoutMs;
    this.type = type;
    this.customConfigFolderPath = customConfigFolderPath;
    this.jupyterProcess = null;
    this.jupyterLog = [];
    this.jupyterPort = null;
    this.jupyterToken = null;
    this.events = new import_events.EventEmitter();
    this.status = "exited" /* EXITED */;
    this.runningType = null;
    this.jupyterExitListener = this.onJupyterExit.bind(this);
    this.jupyterTimoutListener = (0, import_obsidian.debounce)(this.onJupyterTimeout.bind(this), this.jupyterTimeoutMs, true);
    this.jupyerTimedOut = false;
  }
  on(event, callback) {
    this.events.on(event, callback);
  }
  off(event, callback) {
    this.events.off(event, callback);
  }
  once(event, callback) {
    this.events.once(event, callback);
  }
  isRunning() {
    return this.jupyterProcess !== null && this.jupyterProcess.exitCode === null && this.status === "running" /* RUNNING */;
  }
  start() {
    if (this.getStatus() !== "exited" /* EXITED */) {
      return;
    }
    this.jupyterLog = [];
    let env = void 0;
    if (this.customConfigFolderPath !== null) {
      env = {
        ...process.env,
        JUPYTER_CONFIG_PATH: `${this.customConfigFolderPath}${process.env.JUPYTER_CONFIG_PATH ? import_path.delimiter + process.env.JUPYTER_CONFIG_PATH : ""}`
      };
    }
    try {
      this.jupyterProcess = (0, import_child_process.spawn)(this.pythonExecutable, ["-m", this.type === "notebook" /* NOTEBOOK */ ? "notebook" : "jupyterlab", "--no-browser"], {
        cwd: this.path,
        env
      });
    } catch (e) {
      this.jupyterProcess = null;
      this.events.emit("error" /* ERROR */, this, "Jupyter process could not be spawned." /* UNABLE_TO_START_JUPYTER */);
      return;
    }
    this.jupyterProcess.stderr.on("data", this.processJupyterOutput.bind(this));
    this.jupyterProcess.stdout.on("data", this.processJupyterOutput.bind(this));
    this.jupyterProcess.on("exit", this.jupyterExitListener);
    this.jupyterProcess.on("error", this.jupyterExitListener);
    if (this.jupyterTimeoutMs > 0) {
      this.jupyterTimoutListener();
    }
    this.runningType = this.type;
    this.status = "starting" /* STARTING */;
    this.events.emit("starting" /* STARTING */, this);
    this.events.emit("change" /* CHANGE */, this);
  }
  onJupyterTimeout() {
    if (this.status == "starting" /* STARTING */) {
      this.jupyerTimedOut = true;
      this.exit();
    }
  }
  processJupyterOutput(data) {
    data = data.toString();
    this.jupyterLog.push(data);
    if (this.printDebug) {
      console.debug(data.toString());
    }
    if (this.status == "starting" /* STARTING */) {
      const regex = new RegExp(`http://localhost:(\\d+)/(?:${this.runningType === "notebook" /* NOTEBOOK */ ? "tree" : "lab"})\\?token=(\\w+)`);
      const match = data.match(regex);
      if (match) {
        this.jupyterTimoutListener.cancel();
        this.jupyterPort = parseInt(match[1]);
        this.jupyterToken = match[2];
        this.status = "running" /* RUNNING */;
        this.events.emit("ready" /* READY */, this);
        this.events.emit("change" /* CHANGE */, this);
      }
    }
  }
  setPythonExecutable(value) {
    this.pythonExecutable = value;
  }
  printDebugMessages(value) {
    this.printDebug = value;
  }
  setType(value) {
    this.type = value;
  }
  setJupyterTimeoutMs(value) {
    if (value >= 0) {
      this.jupyterTimeoutMs = value;
      if (value > 0) {
        this.jupyterTimoutListener = (0, import_obsidian.debounce)(this.onJupyterTimeout.bind(this), this.jupyterTimeoutMs, true);
      }
    }
  }
  setCustomConfigFolderPath(value) {
    this.customConfigFolderPath = value;
  }
  getCustomConfigFolderPath() {
    return this.customConfigFolderPath;
  }
  getJupyterTimeoutMs() {
    return this.jupyterTimeoutMs;
  }
  getRunningType() {
    return this.runningType;
  }
  getStatus() {
    return this.status;
  }
  getPort() {
    return this.jupyterPort;
  }
  getToken() {
    return this.jupyterToken;
  }
  getLog() {
    return this.jupyterLog;
  }
  getLastLog() {
    if (this.jupyterLog.length === 0) {
      return "";
    }
    return this.jupyterLog[this.jupyterLog.length - 1];
  }
  /**
   * @param file The path of the file relative to the Jupyter environment's working directy.
   */
  getFileUrl(file) {
    if (!this.isRunning()) {
      return null;
    }
    return `http://localhost:${this.jupyterPort}/${this.runningType === "notebook" /* NOTEBOOK */ ? "notebooks" : "lab/tree"}/${file}?token=${this.jupyterToken}`;
  }
  exit() {
    if (this.getStatus() !== "exited" /* EXITED */ && this.jupyterProcess !== null) {
      this.jupyterProcess.kill("SIGINT");
    }
  }
  onJupyterExit(_code, _signal) {
    if (this.jupyterProcess === null) {
      return;
    }
    if (this.jupyterProcess.exitCode !== null && this.jupyterProcess.exitCode !== 0) {
      this.events.emit("error" /* ERROR */, this, "Jupyter process crashed." /* JUPYTER_EXITED_WITH_ERROR */);
    } else if (this.jupyerTimedOut) {
      this.jupyerTimedOut = false;
      this.events.emit("error" /* ERROR */, this, "Jupyter process took too long to start, assumed something was wrong." /* JUPYTER_STARTING_TIMEOUT */);
    } else if (this.status === "starting" /* STARTING */) {
      this.events.emit("error" /* ERROR */, this, "Jupyter process exited." /* JUPYTER_EXITED_WITHOUT_ERROR */);
    }
    this.jupyterProcess = null;
    this.jupyterPort = null;
    this.jupyterToken = null;
    this.runningType = null;
    this.status = "exited" /* EXITED */;
    this.events.emit("exit" /* EXIT */, this);
    this.events.emit("change" /* CHANGE */, this);
  }
};

// src/ui/jupyter-view.ts
var import_obsidian2 = require("obsidian");
var JUPYTER_VIEW_TYPE = "jupyter-view";
var EmbeddedJupyterView = class extends import_obsidian2.FileView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
    this.changeEventListener = this.onJupyterEnvironmentStatusChange.bind(this);
    this.openedFile = null;
    this.messageContainerEl = null;
    this.messageHeaderEl = null;
    this.messageTextEl = null;
    this.webviewEl = null;
  }
  getViewType() {
    return JUPYTER_VIEW_TYPE;
  }
  getDisplayText() {
    var _a, _b;
    return (_b = (_a = this.openedFile) == null ? void 0 : _a.name) != null ? _b : "New Jupyter tab";
  }
  getIcon() {
    return "none";
  }
  displayMessage(header, text, button = null) {
    this.contentEl.empty();
    this.messageContainerEl = this.contentEl.createDiv();
    this.messageContainerEl.addClass("jupyter-message-container");
    this.messageHeaderEl = this.messageContainerEl.createEl("h2");
    this.messageHeaderEl.addClass("jupyter-message-header");
    this.messageHeaderEl.setText(header);
    this.messageTextEl = this.messageContainerEl.createEl("p");
    this.messageTextEl.addClass("jupyter-message-text");
    this.messageTextEl.setText(text);
    if (button !== null) {
      let buttonEl = new import_obsidian2.ButtonComponent(this.messageContainerEl);
      buttonEl.setButtonText(button.text);
      buttonEl.onClick(button.onClick.bind(this));
    }
  }
  async onLoadFile(file) {
    this.openedFile = file;
    switch (this.plugin.env.getStatus()) {
      case "exited" /* EXITED */:
        if (this.plugin.settings.startJupyterAuto) {
          this.displayExitMessage();
          this.plugin.toggleJupyter();
        } else {
          this.displayMessage("No Jupyter server", "Jupyter does not seem to be running. Please make sure to start the server manually using the plugin's ribbon icon or settings. You can also enable automatic start of the Jupyter server when a document is opened in the settings.");
          return;
        }
        break;
      case "running" /* RUNNING */:
        await this.onJupyterRunning(this.plugin.env);
        break;
      default:
        this.displayMessage("Unknown error", "An unknown error has happened when loading the file. Please try closing and re-opening it.");
        break;
    }
  }
  async onJupyterEnvironmentStatusChange(env) {
    switch (env.getStatus()) {
      case "starting" /* STARTING */:
        this.displayMessage("Jupyter is starting", "The Jupyter server is not ready yet. Your document will be opened shortly.");
        break;
      case "running" /* RUNNING */:
        await this.onJupyterRunning(env);
        break;
      case "exited" /* EXITED */:
        this.displayExitMessage();
        break;
      default:
        this.displayMessage("Unknown error", "An unknown error has happened when loading the file. Please try closing and re-opening it.");
        break;
    }
  }
  displayExitMessage() {
    this.displayMessage(
      "Jupyter server exited",
      "The Jupyter server has exited. Please restart the server to view the file.",
      {
        text: "Start Jupyter",
        onClick: () => {
          this.plugin.env.start();
        },
        closeOnClick: false
      }
    );
  }
  async onJupyterRunning(env) {
    if (this.openedFile === null) {
      this.displayMessage("No opened file", "Click on a file in the explorer view to open it here.");
      return;
    }
    if (!env.isRunning()) {
      this.displayMessage("Unknown error", "An unknown error has happened when loading the page. Please try closing and re-opening it.");
      return;
    }
    this.contentEl.empty();
    this.displayMessage("Loading " + this.openedFile.name, "Your file will be displayed shortly.");
    this.webviewEl = this.contentEl.createEl("webview");
    this.webviewEl.setAttribute("allowpopups", "");
    this.webviewEl.setAttribute("partition", "persist:surfing-vault-" + this.app.appId);
    this.webviewEl.addClass("jupyter-webview", "jupyter-webview-loading");
    this.webviewEl.setAttribute("src", env.getFileUrl(this.openedFile.path));
    this.webviewEl.addEventListener("dom-ready", ((_event) => {
      var _a, _b, _c, _d;
      (_a = this.messageContainerEl) == null ? void 0 : _a.remove();
      this.messageContainerEl = null;
      (_b = this.messageHeaderEl) == null ? void 0 : _b.remove();
      this.messageHeaderEl = null;
      (_c = this.messageTextEl) == null ? void 0 : _c.remove();
      this.messageTextEl = null;
      (_d = this.webviewEl) == null ? void 0 : _d.removeClass("jupyter-webview-loading");
    }).bind(this));
  }
  async onOpen() {
    this.plugin.env.on("change" /* CHANGE */, this.changeEventListener);
  }
  async onClose() {
    this.openedFile = null;
    this.messageContainerEl = null;
    this.messageHeaderEl = null;
    this.messageTextEl = null;
    this.webviewEl = null;
    this.plugin.env.off("change" /* CHANGE */, this.changeEventListener);
  }
};

// src/jupyter-settings.ts
var import_obsidian4 = require("obsidian");

// src/ui/jupyter-modal.ts
var import_obsidian3 = require("obsidian");
var JupyterModal = class extends import_obsidian3.Modal {
  constructor(app, heading, message, buttons) {
    super(app);
    this.heading = heading;
    this.message = message;
    this.buttons = buttons;
  }
  onOpen() {
    this.contentEl.createEl("h1", { text: this.heading });
    for (const message of this.message) {
      this.contentEl.createEl("p", { text: message });
    }
    if (this.buttons.length > 0) {
      let setting = new import_obsidian3.Setting(this.contentEl);
      this.buttons.forEach(((button) => {
        setting.addButton(((buttonEl) => {
          buttonEl.setButtonText(button.text);
          buttonEl.onClick(() => {
            button.onClick();
            if (button.closeOnClick) {
              this.close();
            }
          });
        }).bind(this));
      }).bind(this));
    }
  }
};

// src/ui/jupyter-restart-modal.ts
var JupyterRestartModal = class extends JupyterModal {
  constructor(plugin, settingName) {
    super(
      plugin.app,
      "Jupyter restart needed",
      [
        `You just changed the '${settingName}' setting.`,
        "To apply this change, you need to restart Jupyter. Note that restarting Jupyter could cause you to lose your current work if you have not saved it.",
        "Do you want to restart Jupyter now?"
      ],
      [
        {
          text: "No, restart later",
          onClick: () => {
          },
          closeOnClick: true
        },
        {
          text: "Yes, restart now",
          onClick: async () => {
            await plugin.restartJupyter();
          },
          closeOnClick: true
        }
      ]
    );
  }
};

// src/jupyter-settings.ts
var DEFAULT_SETTINGS = {
  pythonExecutable: "python" /* PYTHON */,
  pythonExecutablePath: "",
  startJupyterAuto: true,
  jupyterEnvType: "lab" /* LAB */,
  deleteCheckpoints: false,
  moveCheckpointsToTrash: true,
  displayRibbonIcon: true,
  useStatusNotices: true,
  jupyterTimeoutMs: 3e4,
  debugConsole: false
};
var JupyterSettingsTab = class extends import_obsidian4.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    this.containerEl.empty();
    new import_obsidian4.Setting(this.containerEl).setName("Python").setHeading();
    new import_obsidian4.Setting(this.containerEl).setName("Python executable to use").setDesc("Choose whether to simply use the `python` command or a specific path. Note that you will need to restart your Jupyter server if it is running before this setting is applied.").addDropdown(((dropdown) => {
      dropdown.addOption("python" /* PYTHON */, "`python` command").addOption("path" /* PATH */, "Specified executable path").setValue(this.plugin.settings.pythonExecutable).onChange((async (value) => {
        await this.plugin.setPythonExecutable(value);
      }).bind(this));
    }).bind(this));
    new import_obsidian4.Setting(this.containerEl).setName("Python executable path").setDesc("The path to the Python executable to use. This setting is only used if the previous setting is set to `Specified executable path`.").addText(((text) => {
      text.setPlaceholder("Path to Python executable").setValue(this.plugin.settings.pythonExecutablePath).onChange((async (value) => {
        await this.plugin.setPythonExecutablePath(value);
      }).bind(this));
    }).bind(this));
    new import_obsidian4.Setting(this.containerEl).setName("Jupyter").setHeading();
    new import_obsidian4.Setting(this.containerEl).setName("Server running").setDesc("Start or stop the Jupyter server.").addToggle(((toggle) => toggle.setValue(this.plugin.env.getStatus() !== "exited" /* EXITED */).onChange(((value) => {
      if (this.plugin.env.getStatus() === "starting" /* STARTING */ && !value) {
        toggle.setValue(true);
        new import_obsidian4.Notice("Can't change status while Jupyter server is starting.");
      } else {
        this.plugin.toggleJupyter();
      }
    }).bind(this))).bind(this));
    new import_obsidian4.Setting(this.containerEl).setName("Start Jupyter automatically").setDesc("If a .ipynb file is opened, a Jupyter server will be started automatically if needed.").addToggle(((toggle) => {
      toggle.setValue(this.plugin.settings.startJupyterAuto).onChange((async (value) => {
        await this.plugin.setStartJupyterAuto(value);
      }).bind(this));
    }).bind(this));
    new import_obsidian4.Setting(this.containerEl).setName("Jupyter environment type").setDesc("Select whether to start Jupyter Notebook or Jupyter Lab.").addDropdown(((dropdown) => {
      dropdown.addOption("lab" /* LAB */, "Jupyter Lab").addOption("notebook" /* NOTEBOOK */, "Jupyter Notebook").setValue(this.plugin.settings.jupyterEnvType).onChange((async (value) => {
        await this.plugin.setJupyterEnvType(value);
        if (this.plugin.env.getStatus() !== "exited" /* EXITED */) {
          new JupyterRestartModal(this.plugin, "Jupyter environment type").open();
        }
      }).bind(this));
    }).bind(this));
    new import_obsidian4.Setting(this.containerEl).setName("Delete Jupyter checkpoints").setDesc("To keep your Obsidian vault clean. Does not work retroactively. Restarting Jupyter is required for the setting to take effect.").addToggle(((toggle) => {
      toggle.setValue(this.plugin.settings.deleteCheckpoints).onChange((async (value) => {
        await this.plugin.setDeleteCheckpoints(value);
        if (this.plugin.env.getStatus() !== "exited" /* EXITED */) {
          new JupyterRestartModal(this.plugin, "Delete Jupyter checkpoints").open();
        }
      }).bind(this));
    }).bind(this));
    new import_obsidian4.Setting(this.containerEl).setName("Move Jupyter checkpoints to trash").setDesc("Has no effect if 'Delete Jupyter checkpoints' is not enabled. If enabled, checkpoints are moved to system trash. Otherwise, they are permanently deleted.").addToggle(((toggle) => {
      toggle.setValue(this.plugin.settings.moveCheckpointsToTrash).onChange((async (value) => {
        await this.plugin.setMoveCheckpointsToTrash(value);
      }).bind(this));
    }).bind(this));
    new import_obsidian4.Setting(this.containerEl).setName("Plugin customization").setHeading();
    new import_obsidian4.Setting(this.containerEl).setName("Display ribbon icon").setDesc("Define whether or not you want this Jupyter plugin to use a ribbon icon.").addToggle(((toggle) => toggle.setValue(this.plugin.settings.displayRibbonIcon).onChange((async (value) => {
      await this.plugin.setRibbonIconSetting(value);
    }).bind(this))).bind(this));
    new import_obsidian4.Setting(this.containerEl).setName("Display status notices").setDesc("If enabled, short messages will pop up when the Jupyter server is starting, running or exits.").addToggle(((toggle) => toggle.setValue(this.plugin.settings.useStatusNotices).onChange((async (value) => {
      await this.plugin.setStatusNoticesSetting(value);
    }).bind(this))).bind(this));
    new import_obsidian4.Setting(this.containerEl).setName("Advanced").setHeading();
    new import_obsidian4.Setting(this.containerEl).setName("Jupyter starting timeout").setDesc("To avoid Jupyter being stuck in the starting phase, a timeout is set by default. You can set how many seconds to wait before killing the Jupyter server. Set to 0 to disable the timeout. Please note that a timeout too small might prevent Jupyter from ever starting.").addSlider(((slider) => {
      slider.setLimits(0, 60, 1).setValue(this.plugin.settings.jupyterTimeoutMs / 1e3).setDynamicTooltip().onChange((async (value) => {
        await this.plugin.setJupyterTimeoutMs(value * 1e3);
      }).bind(this));
    }).bind(this));
    new import_obsidian4.Setting(this.containerEl).setName("Print Jupyter output to Obsidian console.").setDesc("When you start Jupyter through a terminal, it prints a bunch of messages. You can get those messages in the Obsidian console by enabling this setting and opening the console (see key binds on the Obsidian website). This can help you if your Jupyter server does not start for some reason.").addToggle(((toggle) => {
      toggle.setValue(this.plugin.settings.debugConsole).onChange((async (value) => {
        await this.plugin.setDebugConsole(value);
      }).bind(this));
    }).bind(this));
  }
};

// src/jupyter-obsidian.ts
var JupyterNotebookPlugin = class extends import_obsidian5.Plugin {
  constructor() {
    super(...arguments);
    /*=====================================================*/
    /* Plugin instance properties                          */
    /*=====================================================*/
    this.settings = DEFAULT_SETTINGS;
    this.ribbonIcon = null;
    this.env = new JupyterEnvironment(
      this.app.vault.adapter.getBasePath(),
      DEFAULT_SETTINGS.debugConsole,
      DEFAULT_SETTINGS.pythonExecutable === "python" /* PYTHON */ ? "python" : DEFAULT_SETTINGS.pythonExecutablePath,
      DEFAULT_SETTINGS.jupyterTimeoutMs,
      DEFAULT_SETTINGS.jupyterEnvType,
      null
    );
    this.envProperlyInitialized = false;
    this.startEnvOnceInitialized = false;
  }
  /*=====================================================*/
  /* Obsidian hooks (load, unload)                       */
  /*=====================================================*/
  async onload() {
    await this.loadSettings();
    this.env.printDebugMessages(this.settings.debugConsole);
    this.env.setPythonExecutable(this.settings.pythonExecutable === "python" /* PYTHON */ ? "python" : this.settings.pythonExecutablePath);
    this.env.setJupyterTimeoutMs(this.settings.jupyterTimeoutMs);
    this.env.setType(this.settings.jupyterEnvType);
    if (this.settings.deleteCheckpoints) {
      this.env.setCustomConfigFolderPath(this.getCustomJupyterConfigFolderPath());
    }
    this.env.on("change" /* CHANGE */, this.showStatusMessage.bind(this));
    this.env.on("change" /* CHANGE */, this.updateRibbon.bind(this));
    this.env.on("error" /* ERROR */, this.onEnvironmentError.bind(this));
    this.env.on("exit" /* EXIT */, this.onJupyterExit.bind(this));
    this.envProperlyInitialized = true;
    if (this.startEnvOnceInitialized) {
      this.toggleJupyter();
    }
    this.ribbonIcon = this.addRibbonIcon("monitor-play", "Start Jupyter Server", this.toggleJupyter.bind(this));
    this.registerView("jupyter-view", (leaf) => new EmbeddedJupyterView(leaf, this));
    this.registerExtensions(["ipynb"], "jupyter-view");
    this.addSettingTab(new JupyterSettingsTab(this.app, this));
  }
  async onunload() {
    await this.saveSettings();
    this.env.exit();
    await this.purgeJupyterCheckpoints();
  }
  /*=====================================================*/
  /* UI Events (ribbon icon, server setting)             */
  /*=====================================================*/
  async toggleJupyter() {
    if (!this.envProperlyInitialized) {
      this.startEnvOnceInitialized = true;
      return;
    }
    switch (this.env.getStatus()) {
      case "exited" /* EXITED */:
        if (this.settings.deleteCheckpoints && !await this.customJupyterConfigExists()) {
          await this.generateJupyterConfig();
        }
        this.env.start();
        break;
      case "running" /* RUNNING */:
        this.env.exit();
        break;
    }
  }
  /**
   * Restarts the Jupyter server if it is running.
   * 
   * If Jupyter is not running, it is simply started.
   */
  async restartJupyter() {
    if (this.env.getStatus() === "exited" /* EXITED */) {
      this.toggleJupyter();
    } else {
      this.env.once("exit" /* EXIT */, (() => {
        this.toggleJupyter();
      }).bind(this));
      this.env.exit();
    }
  }
  /*=====================================================*/
  /* Settings (load, save, set values)                   */
  /*=====================================================*/
  async loadSettings() {
    this.settings = Object.assign(DEFAULT_SETTINGS, await this.loadData());
  }
  async setPythonExecutable(value) {
    this.settings.pythonExecutable = value;
    await this.saveSettings();
    switch (value) {
      case "python" /* PYTHON */:
        this.env.setPythonExecutable("python");
        break;
      case "path" /* PATH */:
        this.env.setPythonExecutable(this.settings.pythonExecutablePath);
        break;
    }
  }
  async setPythonExecutablePath(value) {
    this.settings.pythonExecutablePath = value;
    await this.saveSettings();
    if (this.settings.pythonExecutable === "path" /* PATH */) {
      this.env.setPythonExecutable(value);
    }
  }
  async setStartJupyterAuto(value) {
    this.settings.startJupyterAuto = value;
    await this.saveSettings();
  }
  async setJupyterEnvType(value) {
    this.settings.jupyterEnvType = value;
    await this.saveSettings();
    this.env.setType(value);
  }
  async setDeleteCheckpoints(value) {
    this.settings.deleteCheckpoints = value;
    await this.saveSettings();
    if (value) {
      await this.generateJupyterConfig();
      this.env.setCustomConfigFolderPath(this.getCustomJupyterConfigFolderPath());
    } else {
      await this.deleteJupyterConfig();
      this.env.setCustomConfigFolderPath(null);
    }
  }
  async setMoveCheckpointsToTrash(value) {
    this.settings.moveCheckpointsToTrash = value;
    await this.saveSettings();
  }
  async setRibbonIconSetting(value) {
    var _a;
    this.settings.displayRibbonIcon = value;
    await this.saveSettings();
    if (!value) {
      (_a = this.ribbonIcon) == null ? void 0 : _a.remove();
      this.ribbonIcon = null;
    } else {
      this.ribbonIcon = this.addRibbonIcon("monitor-play", "Start Jupyter Server", this.toggleJupyter.bind(this));
      this.updateRibbon(this.env);
    }
  }
  async setStatusNoticesSetting(value) {
    this.settings.useStatusNotices = value;
    await this.saveSettings();
  }
  async setJupyterTimeoutMs(value) {
    this.settings.jupyterTimeoutMs = value;
    await this.saveSettings();
    this.env.setJupyterTimeoutMs(value);
  }
  async setDebugConsole(value) {
    this.settings.debugConsole = value;
    await this.saveSettings();
    this.env.printDebugMessages(this.settings.debugConsole);
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  /*=====================================================*/
  /* Jupyter Environment event (on change, error, exit)  */
  /*=====================================================*/
  showStatusMessage() {
    if (!this.settings.useStatusNotices) {
      return;
    }
    switch (this.env.getStatus()) {
      case "starting" /* STARTING */:
        new import_obsidian5.Notice("Jupyter Server is starting");
        break;
      case "running" /* RUNNING */:
        new import_obsidian5.Notice("Jupyter Server is now running");
        break;
      case "exited" /* EXITED */:
        new import_obsidian5.Notice("Jupyter Server has exited");
        break;
    }
  }
  onEnvironmentError(_env, error) {
    if (error === "Jupyter process took too long to start, assumed something was wrong." /* JUPYTER_STARTING_TIMEOUT */) {
      new JupyterModal(
        this.app,
        "Jupyter Timeout",
        [
          "The Jupyter server took too long to start.",
          "You can set in the settings the maximum time the plugin will wait for the server to start.",
          "Your current timeout is set to " + this.settings.jupyterTimeoutMs / 1e3 + " second(s).",
          this.settings.jupyterTimeoutMs < 15e3 ? "This is a very short timeout and might not be enough for the server to start. Please try increasing it and see if the error disappears." : "This timeout seems reasonable, hence the problem might be elsewhere depending on your specific situation."
        ],
        [
          {
            text: "Open troubleshooting guide",
            onClick: () => {
              window.open("https://jupyter.mael.im/troubleshooting#jupyter-timeout", "_blank");
            },
            closeOnClick: false
          }
        ]
      ).open();
    } else if (error === "Jupyter process could not be spawned." /* UNABLE_TO_START_JUPYTER */) {
      new JupyterModal(
        this.app,
        "Couldn't start Jupyter",
        [
          "Jupyter could not even be started.",
          "Please check your Python executable and make sure Jupyter is installed in the corresponding environment.",
          "Use the button below to open the troubleshooting guide."
        ],
        [
          {
            text: "Open troubleshooting guide",
            onClick: () => {
              window.open("https://jupyter.mael.im/troubleshooting#jupyter-process-could-not-be-spawned", "_blank");
            },
            closeOnClick: false
          }
        ]
      );
    } else if (error === "Jupyter process crashed." /* JUPYTER_EXITED_WITH_ERROR */) {
      new JupyterModal(
        this.app,
        "Jupyter crashed",
        [
          "Jupyter crashed while starting",
          "Use the button below to open the troubleshooting guide.",
          "Here is the last log message from Jupyter:",
          this.env.getLastLog()
        ],
        [
          {
            text: "Open troubleshooting guide",
            onClick: () => {
              window.open("https://jupyter.mael.im/troubleshooting#jupyter-process-crashed", "_blank");
            },
            closeOnClick: false
          }
        ]
      ).open();
    } else {
      new JupyterModal(
        this.app,
        "Jupyter exited",
        [
          "Jupyter crashed while starting but did not encounter an error.",
          "This is a very rare case and might be due to an 'exit()' statement that got lost in your Jupyter configuration.",
          "Use the button below to open the troubleshooting guide.",
          "Here is the last log message from Jupyter:",
          this.env.getLastLog()
        ],
        [
          {
            text: "Open troubleshooting guide",
            onClick: () => {
              window.open("https://jupyter.mael.im/troubleshooting#jupyter-process-exited", "_blank");
            },
            closeOnClick: false
          }
        ]
      ).open();
    }
  }
  async updateRibbon(env) {
    if (this.ribbonIcon === null || !this.settings.displayRibbonIcon) {
      return;
    }
    switch (env.getStatus()) {
      case "starting" /* STARTING */:
        (0, import_obsidian5.setIcon)(this.ribbonIcon, "monitor-dot");
        (0, import_obsidian5.setTooltip)(this.ribbonIcon, "Jupyter Server is starting");
        break;
      case "running" /* RUNNING */:
        (0, import_obsidian5.setIcon)(this.ribbonIcon, "monitor-stop");
        (0, import_obsidian5.setTooltip)(this.ribbonIcon, "Stop Jupyter Server");
        break;
      case "exited" /* EXITED */:
        (0, import_obsidian5.setIcon)(this.ribbonIcon, "monitor-play");
        (0, import_obsidian5.setTooltip)(this.ribbonIcon, "Start Jupyter Server");
        break;
    }
  }
  async onJupyterExit(_env) {
    await this.purgeJupyterCheckpoints();
  }
  /*=====================================================*/
  /* Jupyter checkpoints management                      */
  /*=====================================================*/
  async purgeJupyterCheckpoints() {
    const checkpointsRelativeFolder = (0, import_obsidian5.normalizePath)(this.getCheckpointsRelativeRootFolder());
    if (!this.settings.deleteCheckpoints || this.settings.moveCheckpointsToTrash) {
      this.app.vault.adapter.trashSystem(checkpointsRelativeFolder);
    } else {
      this.app.vault.adapter.rmdir(checkpointsRelativeFolder, true);
    }
  }
  getCheckpointsRelativeRootFolder() {
    return this.getCustomJupyterConfigFolderRelativePath() + ".ipynb_checkpoints/";
  }
  /**
   * For the feature that gets rid of the Jupyter checkpoints, the
   * plugin uses the Jupyter configuration to put all of the checkpoints
   * in a separate folder. This function computes and returns the absolute
   * (system) path to that folder, to pass it to Jupyter.
   * 
   * Ends with a trailing '/'.
   */
  getCheckpointsAbsoluteRootFolder() {
    const absoluteFolderPath = this.getCustomJupyterConfigFolderPath();
    if (absoluteFolderPath === null) {
      return null;
    }
    return absoluteFolderPath + ".ipynb_checkpoints/";
  }
  /**
   * The name of the Jupyter configuration file that the plugin uses
   * to get rid of the checkpoints. No folders involved in this value.
   * 
   * Probably has the form `jupyter_someapp_config.py`.
   */
  getCustomJupyterConfigFilename() {
    return "jupyter_lab_config.py";
  }
  /**
   * Returns the path to the folder where the Jupyter configuration file
   * is placed relative to the vault's root.
   * 
   * Ends with a trailing '/'.
   */
  getCustomJupyterConfigFolderRelativePath() {
    if (this.manifest.dir) {
      return this.manifest.dir + "/";
    } else {
      return this.app.vault.configDir + "/plugins/" + this.manifest.id + "/";
    }
  }
  /**
   * Returns the path to the Jupyter configuration file relative to the
   * vault's root.
   */
  getCustomJupyterConfigFileRelativePath() {
    return this.getCustomJupyterConfigFolderRelativePath() + this.getCustomJupyterConfigFilename();
  }
  /**
   * Returns the absolute path (not relative to the vault's root) to the
   * folder where the Jupyter configuration file is placed.
   * 
   * Returns null if on mobile.
   */
  getCustomJupyterConfigFolderPath() {
    if (this.app.vault.adapter instanceof import_obsidian5.FileSystemAdapter) {
      const relativeFolderPath = this.getCustomJupyterConfigFolderRelativePath();
      return this.app.vault.adapter.getFullPath(relativeFolderPath);
    } else {
      return null;
    }
  }
  /**
   * Indicates whether the Jupyter configuration file exists (true) or
   * needs to be created (false).
   */
  async customJupyterConfigExists() {
    const relativeConfigPath = this.getCustomJupyterConfigFileRelativePath();
    if (relativeConfigPath === null) {
      return false;
    }
    return await this.app.vault.adapter.exists((0, import_obsidian5.normalizePath)(relativeConfigPath));
  }
  /**
   * Generates a Jupyter configuration file in the folder indicated by
   * `getCustomJupyterConfigPath()` with settings to put all checkpoints
   * in a single folder.
   */
  async generateJupyterConfig() {
    const absoluteCheckpointsFolderPath = this.getCheckpointsAbsoluteRootFolder();
    if (absoluteCheckpointsFolderPath === null) {
      return false;
    }
    const relativeConfigPath = this.getCustomJupyterConfigFileRelativePath();
    const configContent = `c.FileContentsManager.checkpoints_kwargs = {'root_dir': r'${absoluteCheckpointsFolderPath}'}
print("[Jupyter for Obsidian] Custom configuration of Jupyter for Obsidian loaded successfully.")`;
    await this.app.vault.adapter.write((0, import_obsidian5.normalizePath)(relativeConfigPath), configContent);
    return true;
  }
  async deleteJupyterConfig() {
    const relativeConfigPath = this.getCustomJupyterConfigFileRelativePath();
    if (relativeConfigPath === null) {
      return;
    }
    await this.app.vault.adapter.remove((0, import_obsidian5.normalizePath)(relativeConfigPath));
  }
};
